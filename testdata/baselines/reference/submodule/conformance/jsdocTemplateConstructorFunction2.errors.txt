templateTagWithNestedTypeLiteral.js(1,1): error TS8004: Type parameter declarations can only be used in TypeScript files.
templateTagWithNestedTypeLiteral.js(2,12): error TS8010: Type annotations can only be used in TypeScript files.
templateTagWithNestedTypeLiteral.js(22,12): error TS8010: Type annotations can only be used in TypeScript files.
templateTagWithNestedTypeLiteral.js(28,15): error TS2304: Cannot find name 'T'.
templateTagWithNestedTypeLiteral.js(30,12): error TS8010: Type annotations can only be used in TypeScript files.


==== templateTagWithNestedTypeLiteral.js (5 errors) ====
    /**
    ~~~
     * @param {T} t
    ~~~~~~~~~~~~~~~
               ~
!!! error TS8010: Type annotations can only be used in TypeScript files.
     * @template T
    ~~~~~~~~~~~~~~
     */
    ~~~
    function Zet(t) {
    ~~~~~~~~~~~~~~~~~
        /** @type {T} */
    ~~~~~~~~~~~~~~~~~~~~
        this.u
    ~~~~~~~~~~
        this.t = t
    ~~~~~~~~~~~~~~
    }
    ~
!!! error TS8004: Type parameter declarations can only be used in TypeScript files.
    /**
     * @param {T} v
     * @param {object} o
     * @param {T} o.nested
     */
    Zet.prototype.add = function(v, o) {
        this.u = v || o.nested
        return this.u
    }
    var z = new Zet(1)
    z.t = 2
    z.u = false
    /** @type {number} */
               ~~~~~~
!!! error TS8010: Type annotations can only be used in TypeScript files.
    let answer = z.add(3, { nested: 4 })
    
    // lookup in typedef should not crash the compiler, even when the type is unknown
    /**
     * @typedef {Object} A
     * @property {T} value
                  ~
!!! error TS2304: Cannot find name 'T'.
     */
    /** @type {A} */
               ~
!!! error TS8010: Type annotations can only be used in TypeScript files.
    const options = { value: null };
    